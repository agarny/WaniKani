/*******************************************************************************

Copyright Alan Garny

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*******************************************************************************/

//==============================================================================
// Widget
//==============================================================================

#include "widget.h"

//==============================================================================

#include <QBuffer>
#include <QColorDialog>
#include <QDate>
#include <QDesktopWidget>
#include <QDir>
#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>
#include <QKeyEvent>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>
#include <QPainter>
#include <QSettings>
#include <QStandardPaths>
#include <QTextStream>

//==============================================================================

#if defined(Q_OS_WIN)
    #include <Windows.h>
#elif defined(Q_OS_MAC)
    #include "macos.h"

    #include <math.h>
#else
    #include <QProcess>
#endif

//==============================================================================

#include "ui_widget.h"

//==============================================================================

static const auto SettingsFileName     = QStringLiteral("FileName");
static const auto SettingsApiKey       = QStringLiteral("ApiKey");
static const auto SettingsCurrentKanji = QStringLiteral("CurrentKanji");
static const auto SettingsInterval     = QStringLiteral("Interval");
static const auto SettingsFontName     = QStringLiteral("FontName");
static const auto SettingsBoldFont     = QStringLiteral("BoldFont");
static const auto SettingsItalicsFont  = QStringLiteral("ItalicsFont");
static const auto SettingsColor        = QStringLiteral("Color%1%2");

//==============================================================================

static const auto LinkStyle = " style=\"color: rgb(103, 103, 103); outline: 0px; text-decoration: none;\"";

//==============================================================================

Widget::Widget() :
    mGui(new Ui::Widget),
    mInitializing(true),
    mFileName(QString()),
    mColors(QMap<QPushButton *, QRgb>()),
    mKanjiError(false),
    mKanjiState(QMap<QString, QString>()),
    mOldKanjiState(QMap<QString, QString>()),
    mNeedToCheckWallpaper(true)
{
    // Set up our GUI

    mGui->setupUi(this);

    setMinimumSize(QSize(1024, 768));

#ifdef Q_OS_MAC
    setWindowFlags(Qt::FramelessWindowHint);
#else
    setWindowFlags(Qt::Popup);
#endif

    connect(mGui->currentKanjiRadioButton, SIGNAL(clicked()),
            this, SLOT(updateLevels()));
    connect(mGui->allKanjiRadioButton, SIGNAL(clicked()),
            this, SLOT(updateLevels()));

    for (int i = 1; i <= 6; ++i) {
        for (int j = 1; j <= 2; ++j) {
            connect(qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, j)->widget()), SIGNAL(clicked()),
                    this, SLOT(updatePushButtonColor()));
        }
    }

    // Some about information

    QFile versionFile(":/version");

    versionFile.open(QIODevice::ReadOnly);

    QTextStream stream(&versionFile);
    QString version = stream.readAll();

    versionFile.close();

    int currentYear = QDate::currentDate().year();

    mGui->aboutValue->setText("<span style=\"font-size: 19px;\"><strong><a href=\"https://github.com/agarny/wanikani\""+QString(LinkStyle)+">WaniKani</a> "+version+"</strong></span><br/>"
                              "Â© 2016"+((currentYear > 2016)?QString("-%1").arg(currentYear):QString())+" <a href=\"https://github.com/agarny\""+QString(LinkStyle)+">Alan Garny</a>");

    // Handle signals from our WaniKani object

    connect(&mWaniKani, SIGNAL(updated()),
            this, SLOT(waniKaniUpdated()));
    connect(&mWaniKani, SIGNAL(error()),
            this, SLOT(waniKaniError()));

    // Retrieve our settings and handle a click on our foreground/background
    // push buttons

    on_resetAllPushButton_clicked(true);

    // Retrieve some initial information about the user's kanji

    updateKanji();

    // Use our timer to update our WaniKani object, as well as retrieve the
    // kanji and set our wallpaper

    connect(&mTimer, SIGNAL(timeout()),
            &mWaniKani, SLOT(update()));
    connect(&mTimer, SIGNAL(timeout()),
            this, SLOT(updateKanji()));

    updateInterval(mGui->intervalSpinBox->value());

    // Create and show our system tray icon

    mTrayIcon.setIcon(QIcon(":/icon"));
    mTrayIcon.setToolTip("WaniKani");

    connect(&mTrayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)),
            this, SLOT(trayIconActivated(const QSystemTrayIcon::ActivationReason &)));

    mTrayIcon.show();

    mInitializing = false;
}

//==============================================================================

#ifdef Q_OS_MAC
void Widget::keyPressEvent(QKeyEvent *pEvent)
{
    // Hide ourselves if the user presses the escape key

    if (pEvent->key() == Qt::Key_Escape)
        hide();
    else
        QWidget::keyPressEvent(pEvent);
}
#endif

//==============================================================================

void Widget::updateInterval(const int &pInterval)
{
    // Update our timer's interval

    mTimer.start(60000*pInterval);
}

//==============================================================================

QString Widget::iconDataUri(const QString &pIcon, const int &pWidth,
                            const int &pHeight, const QIcon::Mode &pMode)
{
    // Convert an icon, which resource name is given, to a data URI, after
    // having resized it, if requested

    QIcon icon(pIcon);

    if (icon.isNull())
        return QString();

    QByteArray data;
    QBuffer buffer(&data);
    QSize iconSize = icon.availableSizes().first();

    buffer.open(QIODevice::WriteOnly);
    icon.pixmap((pWidth == -1)?iconSize.width():pWidth,
                (pHeight == -1)?iconSize.height():pHeight,
                pMode).save(&buffer, "PNG");

    return QString("data:image/png;base64,%1").arg(QString(data.toBase64()));
}

//==============================================================================

void Widget::updateGravatar(const QPixmap &pGravatar)
{
    // Update our gravatar

    mGui->gravatarValue->setPixmap(pGravatar.scaled(80, 80, Qt::KeepAspectRatio, Qt::SmoothTransformation));
}

//==============================================================================

void Widget::updateSrsDistributionPalettes()
{
    // Update the palette of our different SRS distribution information

    QPalette palette;

    palette.setColor(QPalette::Window, mGui->apprenticeBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->apprenticeForegroundPushButton->palette().color(QPalette::Button));

    mGui->apprenticeValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->guruBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->guruForegroundPushButton->palette().color(QPalette::Button));

    mGui->guruValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->masterBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->masterForegroundPushButton->palette().color(QPalette::Button));

    mGui->masterValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->enlightenedBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->enlightenedForegroundPushButton->palette().color(QPalette::Button));

    mGui->enlightenedValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->burnedBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->burnedForegroundPushButton->palette().color(QPalette::Button));

    mGui->burnedValue->setPalette(palette);
}

//==============================================================================

void Widget::updateSrsDistributionInformation(QLabel *pLabel,
                                              const QString &pIcon,
                                              const SrsDistributionInformation &pInformation)
{
    // Update the given SRS distribution information

    pLabel->setText("<img src=\""+iconDataUri(pIcon, 32, 32)+"\"><br/>"+pInformation.total());
    pLabel->setToolTip("<table>\n"
                       "    <tr>\n"
                       "        <td>Radicals:</td>\n"
                       "        <td align=right>"+pInformation.radicals()+"</td>\n"
                       "    </tr>\n"
                       "    <tr>\n"
                       "        <td>Kanji:</td>\n"
                       "        <td align=right>"+pInformation.kanji()+"</td>\n"
                       "    </tr>\n"
                       "    <tr>\n"
                       "        <td>Vocabulary:</td>\n"
                       "        <td align=right>"+pInformation.vocabulary()+"</td>\n"
                       "    </tr>\n"
                       "</table>\n");
}

//==============================================================================

QJsonDocument Widget::waniKaniRequest(const QString &pRequest)
{
    // Make sure that we have an API key

    if (mGui->apiKeyValue->text().isEmpty())
        return QJsonDocument();

    // Send a request to WaniKani and convert its response to a JSON document,
    // if possible

    QNetworkAccessManager networkAccessManager;
    QNetworkReply *networkReply = networkAccessManager.get(QNetworkRequest(QString("https://www.wanikani.com/api/v1/user/%1/%2").arg(mGui->apiKeyValue->text(), pRequest)));
    QEventLoop eventLoop;

    QObject::connect(networkReply, SIGNAL(finished()),
                     &eventLoop, SLOT(quit()));

    eventLoop.exec();

    QByteArray response = QByteArray();

    if (networkReply->error() == QNetworkReply::NoError)
        response = networkReply->readAll();

    networkReply->deleteLater();

    if (response.isEmpty())
        return QJsonDocument();
    else
        return QJsonDocument::fromJson(response);
}

//==============================================================================

static const QString Kanji =
"ä¸äºä¸åäºå­ä¸å«ä¹åå£æ¥æç°ç®å¤å¾åææå±æ¶ååææ©æ­ä¸èæ¦èäºå¹å¸æ§èªç½ç¾ä¸­åèåæä¸¸å¯¸å°å"
"å ä¸ä¸åæåªè²è²å¡è¦ååé é å¡è² ä¸å¥èæ¬åºçé¦ä¹ä¹±ç´å·çå·¥å·¦å³æè³è²¢é åååå¬æ­åå¯å¥ä¸çºå¯é "
"å­å­äºå¥³å¥½å¦æ¯è²«ååå°å°å¤§å¤å¤æ±å¤åç³èç¡ç ç ååå¤ªå¨è­å¦çåå¥å·å·é æ°´æ°·æ°¸æ³åé¡æ³³æ²¼æ²æ±æ±æ½®"
"æºæ´»æ¶æ³æ²³æ³æ¹æ¸¬ååå§å¼å£å­å°æ¶¯å¯ºæåç«çç©æ·¡ç¯çç½ç°ç¹ç§é­æ¼éé»å¢¨é¯éåååæ´è´åå°å­å®å®å®£"
"å®µå®å®´å¯å¯è²¯æ¨ææ£®æ¡ææ æ¢¢æ£ææ¡æ¤æ¯æ´æç¸æºæ¬æ­æ¦æ¡ç¥æªæ«æ²«å³å¦¹æ±æ ªè¥èè¦å¯èèæ¨¡æ¼ å¢æ®èèå"
"æ¡çºç¬ç¶é»ç¶è»ç©ç«çç¹ååæ´ä»çè¶åå¡ççå®ç ç¾ççåå¨æ çä¸»æ³¨æ±ééé¢éé£ééé®éå°è¾»è¿é è¿«"
"éè¾ºå·¡è»é£è»è¼¸ååæ ¼ç¥å®¢é¡å¤å¦æ¡è½åè»è¼éå å¤¢åé«äº«å¡¾çäº­äº¬æ¶¼æ¯é¯¨èå¨é±å£«åå£®èå£²å­¦è¦æ æ¸æ´¥ç§"
"æ»ææææ¬è¨è­¦è¨çè¨è¨è¨è©è©°è©±è© è©©èªèª­èª¿è«è«¾è«­å¼è©¦å¼åè³æ ½è¼èæåèª å¨æ»æ¸æ¡é­æµæ­¢æ­©æ¸é »è¯ä¼æ­´"
"æ­¦è³¦æ­£è¨¼æ¿å®é èµ°è¶èµ´è¶æ¯é¡å ¤å»ºå»¶èªç¤å©¿è¡£è£è£è£å£åé ç¿åå¸å¸å¹å¸½å¹å¹é¦å¸å§èºå¸¯æ»åºå¶è£½è»¢è¸é¨é²"
"æé·éå¬å¤©æ©å¬ç«æ³£ç« ç«¶å¸ç«¥ç³éåå«¡é©æ»´æµååèæ¯æçæ··æ¸è¬è¤åæ¨èå£±æ¯ææ¢æµ·ä¹ä¹¾è¹è¤æ¬ å¹çæ­è»"
"æ¬¡è¨è³å§¿è«®è³ å¹åé³æé»è­é¡å¢äº¡ç²å¦èææ¹å¦¨åè³èªè¨ªæ¾æ¿è±èª¬é­æ½å¢è´æ±æ£åå¦å»·æçè³æ­³çæ å°æ± è«"
"èèè¹è¶ç¬èé¢¨å·±èµ·å¦æ¹è¨åèç ²æ³¡äºé»ç«æ»è±ééå®¶å«è±ªè¸å ´æ¹¯ç¾ç¾æ´è©³é®®éç¾¨å·®çå¯ç¦ç¤éåé²ééæº"
"å¥®å¥ªç¢ºåè¨±æ­æ¨©è¦³ç¾½ç¿ç¿ææ¿¯æ°å°åºå½å£å å§»ååå£åºåº«åº­åºåºéº»ç£¨å¿å¿å¿èªå¿å¿èªå¿ ä¸²æ£ææ©å¿ææ³æ¯æ©"
"æµææææå¯¡å¿æ¦ææ¼ææææææ£ææ°ææ¾æ¶ææ·»å¿æ³æçæ©æç¾©è­°ç æ¹æ±æ­æææ¹ææææææ¨æææ"
"æææ¬æ®æ¨ææææ¾ææ æææ¥æ²æç ææ¢°é¼»ååæè²¡æå­å¨ä¹æºåå¸æ±ä¸å²åæ´ç¡¬ååæ¡é»è­·ç²å¥´æåæ"
"ææ²¡è¨­ææ®»æ¯ææè¢èæªè»½åç£å¯æ·ååæ¿è¿è²©çªå¦¥ä¹³æµ®å°å¥¨æ¡èåæææåºæ¡é±å¼éå°æ æ²»å§èçªå»æ³ä¼"
"è³å®¤å°è´äºæ£è²æ¤åéç¡«æµåååºå±±æå²©ç­å²å³ å´©å¯èåµå´å¥è¾¼åè²§é å¬æ¾ç¿è¨è°·æµ´å®¹æº¶æ¬²è£éæ²¿è³åå å¸¸"
"è£³æç®æ³¢å©æ«ç ´è¢«æ®æ®æ®æ®åè£çæ­»è¬ç¬è³åè¶£ææ®æ¥è·èæ¢è´ææ¢æ¼«è²·ç½®ç½°å¯§æ¿ç°éå¤«æ¶æ¸è¦æ¿è³æ½å¤±é"
"è¿­è£å§«èµèè³¢å è¨è¦§å·¨æåç·å´åå£åå§åªå±å è³æ¶èèåè¡å¾å¾©å¾å¾å¾å¾å¾å¾å¾å½¼å½¹å¾³å¾¹å¾´æ²å¾®è¡è¡¡ç¨¿ç¨¼"
"ç¨ç¨ç¨åç§»ç§ç§æç§ç§©ç§ç§°å©æ¢¨ç©«ç©ç¨²é¦å­£å§ç§éèªç©èç±³ç²ç²ç²ç²§è¿·ç²ç³§èå¥¥æ°æ¥¼é¡æ¼æ§æ±çæç«¹ç¬ç¬ ç¬¹"
"ç­ç®±ç­ç­ç­ç®ç­ç­ç°¿ç¯äººä½ä½ä½ä½ä»²ä½æ ä»¶ä»ä»ä¼ä¼ä»ä¼ä»®ä¼¯ä¿ä¿¡ä½³ä¾ä¾åå¥å´ä¾åå¤å£ååµå§åååä»å¬"
"ä»ä¾®ä½¿ä¾¿ååªä¼å®¿å·ä¿è¤åä»ç¬¦åºä»»è³ä»£è¢è²¸åè±è²¨å¾ä½è·ä¿åä¹çååä¸æèèåº§åååä»¥ä¼¼ä½µç¦ç¶å®®å¶"
"åå¹´å¤æ¶²å¡å¹£å¼åæèæ½æéæå¿ç©æè³å°¿å°¼å°»æ³¥å¡å±¥å±æ¡å±æå å±æ®å±¤å±éæ¼å·å°ºå°½æ²¢è¨³ææ¼æ¸è©æ¿æç"
"æ»æ¶éé¡§åç¤ºç¤¼ç¥¥ç¥ç¦ç¥ç¤¾è¦å¥å°æ°æ¬¾ç¦è¥å®å´ç¥­å¯æ¦ç±æ½æ²¹è¢å®å±ç¬è»¸ç²æ¼å²¬æ¿ç³ä¼¸ç¥ææèèª²è£¸æ¤ææ"
"ç¥è¿æå²éèªæ«æ¼¸æ­è³ªæ¥è¨´æ¨è©ä½éªé²å°æ¥ç©ä¾µæµ¸å¯å©¦æå½äºæµäºåç³åº·é®ä¼åç¾¤èéåç«¯ä¸¡æºç»æ­¯æ²æ¹é­"
"æ¼æ§½ææç§å³ç¨åº¸åæé¯åææªæ£å»¿åº¶é®å¸­åº¦æ¸¡å¥å´å¢³æ¤ç¼æåä¼´çå¤å¸å·»ååè¤è¬ççä¹ä¹èä¸å¦æ¯ç¢ç¯"
"æç¥æºçæåé§ç­å¸°å¼å¼å¼å¼å¼·å¼±æ²¸è²»ç¬¬å¼å·§å·æ½èªæ±ä¸åèº«å°è¬èèå­ææ·èç®èç½²æè«¸çªæ¸è³­å³¡ç­æè¿½"
"å¸«å¸¥å®æ£ºç®¡ç¶äº¤å¹è¼æ ¡è¶³ä¿è·è·¯é²è·³èºè·µè¸éª¨æ»é«ç¦æ¸¦ééªé¿ééééªé½é³é²éé¢é£éå¢éééé£éé å é¥"
"ç©´ç©ºæ§çªç©¶çªçªçªªæ¾çª¯çª®æ¢æ·±ä¸å²³åµæµç³¸ç¹ç¹ç¸®ç¹ç¸¦ç·ç· ç¶­ç¾ç·´ç·ç¶çµµçµ±çµçµ¦çµ¡çµçµç´ç´ç´ç´ç´¡ç´ç´¹çµç´³ç´"
"ç´°ç´¯ç´¢ç·ç¶¿çµ¹ç¹°ç¶ç·ç¸ç¶²ç·ç´«ç¸ç¸å¹¼å¾å¹½å¹¾æ©ççèå¼¦ææ»æç£ç³»ä¿å­«æ¸å´èå¸å¾¡æå½ä»¤é¶é½¢å·é é´åéè¸"
"çæ¬åç¯ç¯åå±å®èèæ¨æ³åµçè²¿å°èééééµé·é¬éªé¢ééé¸ç¶å°è±é ­ç­è±é¼åæ¨¹ç¿è¡çççæ¸©ç£æ¿«éç"
"çå¡©éæ¨æ ¹å³çµç¯ééç¼è¯ææµªå¨é£é£¯é£²é£¢é¤é£¾é¤¨é¤é£½æ¢æ¦æ¨å¹³å¼åªè©åå¸å¶è¸é¢æ®ºç´éè¾è¾æ¢å®°å£é¿æ°èª"
"è¦ªå¹¸å·å ±å«ç³¾ååç¢é¸ç¦å¢ç±è±éµäº¥æ ¸å»è©²å¾è¿°è¡å¯é¸è­²å£å¬¢æ¯ç´ éº¦éç²¾è«ææ´æ¸éè²¬ç¸¾ç©åµæ¼¬è¡¨ä¿µæ½å¥å«"
"å®³è½å²æ²çæå§æ§ç²ç£éå³°ç¸«æå¯¿é³ç±æ¥æ¤¿æ³°å¥å®å¥ä¿¸æ£è¬¹å¤æ¼¢åé£è¯åç¡éä¹å°ä»å«åå¿µç´é°äºåºé éå¼"
"å«éè¬å»è¥¿ä¾¡è¦è°ç¥¨æ¼æ¨æ é·è¦çåæ¥ ç®éåé²é¥éç°¡ééé£éèæ½¤æ¬éååµéä¿³ææ²ç½ªè¼©æä¾¯åæ±ºå¿«åé"
"ç·¯è¡éå¹²èåæ±è»å²¸å¹¹èå®ä½é¤å¾åéæå¡æé ¼ç¬åçéæ´å£éºæ¤å¹éåå²åç¨®è¡è«çç´ççç¾ç¢ç²ç«çç"
"å¿å å»å¹åºæ¢æ®´æ¬§æä»°è¿ç»æ¾çºå»åå¯®çå½«å½¢å½±æå½©å½°å½¦é¡é è¨åæ¨ä¿®çè¨ºæå¯¾ç´èæå¤æ¸æç²å¡æ¥½è¬çæ¸"
"æå¤®è±æ èµ¤èµ¦å¤è·¡è®ææ¹¾é»æ¨ªæè²çµ¶è¶è¥çç´ºæè¬åªæ¬ºæ£ææç¢åºçåå ªè²´éºé£èç¡çµç²ç§ç¥é»æ»å©å®ç³ä¸¦"
"æ®è­æ¹¿é¡ç¹éæ¥­æ²åå±ä¾ç°ç¿¼æ´ªæ¸¯æ´çæ­é¸æ®¿äºå²èäºæªåè§è§¦è§£åè¬è³¼æ§æºè«å«è¼ªåéç·¨åå¸æ°ç´å©ä½æµ"
"åºæ°ç ææµ¦è²èè£é¸é­é¡éé¨é½éµé¦é·é¿éå»ç¾å¾ªæ´¾èè¡éæ®µéåå¹»å¸ä¼ºè©é£¼å£èè¶èªè¬ç¤æ¬è¹è¦èçå¼§å­¤"
"ç¹­çææ·æ¥æ°æ±½é£æ²å¦»è¡°è¡·é¢é©é´è¦å£°åå¨¯èª¤è¸æ¿å½æ¥µçè½éªééçªå¯©ç¿»è©æ¯èå°¾å®è¨çºå½é·å¼µå¸³è¹é«ªå±åª"
"å·£åæ¦ç¦å¼¾æ¡ç£è³æ©å³éæèªçé³¥é³´é¶´çè¦é³©é¶å³¶æåªæ´ç·©å±å±å¶éæééå¡å²¡é¼ç¶±åç¼¶é¶æºè¬¡å°±æå¢¾åé¸"
"æ©åè±¡åé¦¬é§é¨é¨é§é§é§é¨é§é©ç¯¤é¨°èèèèæ¯èæ®åèé¹¿è¦æ¶éºçè½æå¯æ¼è¾°è¾±éæ¯å¨ åè¾²æ¿éé¢å²é¬¼é"
"é­é­é­å¡è¥²åæé°ç®é¬éµç½·å±¯ä¸è»é·çä¸¹æ½ä¸å¯å·³è¬æ¤ç¿è´è¯éä¿ºéæç¶ºéé¤ä¸¼è³ä¼æå¢èæ³éçåèª°åªä¹"
"é å±æ¬éµå·¾ç½éåºç­å´ç®¸æ·å °é°éè²¼è¹é¬±ã";

//==============================================================================

void Widget::updateKanji(const bool &pForceUpdate)
{
    // Reset some internal properties

    mKanjiError = true;
    mKanjiState = QMap<QString, QString>();

    if (pForceUpdate)
        mOldKanjiState = QMap<QString, QString>();

    // Retrieve the list of Kanji (and their state) the user has already studied

    QString request = "kanji";

    if (!mGui->currentKanjiRadioButton->isChecked()) {
        request += "/1";

        for (int i = 2; i <= 60; ++i)
            request += ","+QString::number(i);
    }

    QJsonDocument json = waniKaniRequest(request);

    if (!json.isNull()) {
        mKanjiError = json.object().contains("error");

        QVariantMap requestedInformationMap;

        if (!mKanjiError) {
            foreach (const QVariant &requestedInformation,
                     json.object().toVariantMap()["requested_information"].toList()) {
                requestedInformationMap = requestedInformation.toMap();

                mKanjiState.insert(requestedInformationMap["character"].toString(),
                                   requestedInformationMap["stats"].toMap()["srs"].toString());
            }
        }
    }

    // Update our wallpaper

    updateWallpaper();
}

//==============================================================================

void Widget::updateWallpaper(const bool &pForceUpdate)
{
    // Generate and set the wallpaper, if needed

    if (pForceUpdate || mKanjiError || (mKanjiState != mOldKanjiState)) {
        // Default wallpaper

        QPixmap pixmap;

        pixmap.load(":/wallpaper");

        if (!mKanjiError) {
            // Generate the wallpaper

            static const int LeftBorder = 1240;
            static const int Shift = 32;
            static const int SmallShift = 1;

            QDesktopWidget desktopWidget;
            QRect availableGeometry = desktopWidget.availableGeometry();
            QRect geometry = desktopWidget.geometry();

            int areaWidth = pixmap.width()-LeftBorder-2*Shift;
            int areaHeight = double(availableGeometry.height())/geometry.height()*pixmap.height()-2*Shift;

            QFont font = QFont(mGui->fontComboBox->currentText());

            font.setBold(mGui->boldFontCheckBox->isChecked());
            font.setItalic(mGui->italicsFontCheckBox->isChecked());

            int fontPixelSize = 1;
            int charWidth = 0;
            int charHeight = 0;
            int nbOfRows = 0;
            int nbOfCols = 0;
            int descent = 0;

            forever {
                font.setPixelSize(fontPixelSize);

                QFontMetrics fontMetrics(font);
                int crtCharWidth = fontMetrics.width(Kanji.at(0));
                int crtCharHeight = fontMetrics.height();
                int crtNbOfCols = areaWidth/(crtCharWidth+SmallShift);
                int crtNbOfRows =  floor(mKanjiState.size()/crtNbOfCols)
                                  +((mKanjiState.size() % crtNbOfCols)?1:0);

                if (crtNbOfRows*crtCharHeight+(crtNbOfRows-1)*SmallShift+fontMetrics.descent() <= areaHeight) {
                    charWidth = crtCharWidth;
                    charHeight = crtCharHeight;

                    nbOfRows = crtNbOfRows;
                    nbOfCols = crtNbOfCols;

                    descent = fontMetrics.descent();

                    ++fontPixelSize;
                } else {
                    font.setPixelSize(fontPixelSize-1);

                    break;
                }
            }

            QPainter painter(&pixmap);

            painter.setFont(font);

            int xStart = LeftBorder+Shift+((areaWidth-nbOfCols*charWidth-(nbOfCols-1)*SmallShift) >> 1);
            int x = 0;
            int y =  double(availableGeometry.top())/geometry.height()*pixmap.height()
                    +Shift+((areaHeight-nbOfRows*charHeight-(nbOfRows-1)*SmallShift) >> 1)-descent;
            int radius = ceil(0.75*(qMax(charWidth, charHeight) >> 3));

            for (int i = 0, j = 0, iMax = Kanji.size(); i < iMax; ++i) {
                if (mKanjiState.keys().contains(Kanji.at(i))) {
                    if (!(j % nbOfCols)) {
                        x = xStart;
                        y += charHeight+(j?SmallShift:0);
                    }

                    QString state = mKanjiState.value(Kanji.at(i));
                    QColor foregroundColor;
                    QColor backgroundColor;

                    if (!state.compare("apprentice")) {
                        foregroundColor = color(2, 1);
                        backgroundColor = color(2, 2);
                    } else if (!state.compare("guru")) {
                        foregroundColor = color(3, 1);
                        backgroundColor = color(3, 2);
                    } else if (!state.compare("master")) {
                        foregroundColor = color(4, 1);
                        backgroundColor = color(4, 2);
                    } else if (!state.compare("enlighten")) {
                        foregroundColor = color(5, 1);
                        backgroundColor = color(5, 2);
                    } else if (!state.compare("burned")) {
                        foregroundColor = color(6, 1);
                        backgroundColor = color(6, 2);
                    } else {
                        foregroundColor = color(1, 1);
                        backgroundColor = color(1, 2);
                    }

                    painter.setPen(foregroundColor);

                    QPainterPath path;

                    path.addRoundedRect(QRectF(x, y-charHeight+descent, charWidth, charHeight),
                                        radius, radius);

                    painter.fillPath(path, QColor(backgroundColor));
                    painter.drawText(x, y, Kanji.at(i));

                    x += charWidth+SmallShift;

                    ++j;
                }
            }
        }

        // Delete our old wallpaper and save our new one before setting it

        if (!mFileName.isEmpty())
            QFile(mFileName).remove();

        mFileName = QDir::toNativeSeparators(QStandardPaths::writableLocation(QStandardPaths::PicturesLocation)+QDir::separator()+QString("WaniKani%1.jpg").arg(QDateTime::currentMSecsSinceEpoch()));

        pixmap.save(mFileName);

        setWallpaper();
    }

    // Ask for a wallpaper to be checked in about one second, if necessary

    if (mNeedToCheckWallpaper) {
        mNeedToCheckWallpaper = false;

        QTimer::singleShot(1000, this, SLOT(checkWallpaper()));
    }
}

//==============================================================================

void Widget::setWallpaper()
{
    // Set the new wallpaper

#if defined(Q_OS_WIN)
    SystemParametersInfo(SPI_SETDESKWALLPAPER, 0,
                         PVOID(mFileName.utf16()), SPIF_UPDATEINIFILE);
#elif defined(Q_OS_MAC)
    setMacosWallpaper(qPrintable(mFileName));
#else
    QProcess process;

    process.start("gsettings",
                  QStringList() << "set"
                                << "org.gnome.desktop.background"
                                << "picture-options"
                                << "stretched");
    process.waitForFinished();

    process.start("gsettings",
                  QStringList() << "set"
                                << "org.gnome.desktop.background"
                                << "picture-uri"
                                << QUrl::fromLocalFile(mFileName).toString());
    process.waitForFinished();
#endif
}

//==============================================================================

QColor Widget::color(const int &pRow, const int &pColumn) const
{
    // Return whether our font is to be in italics

    QRgb rgba = mColors.value(qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(pRow, pColumn)->widget()));

    return QColor(qRed(rgba), qGreen(rgba), qBlue(rgba), qAlpha(rgba));
}

//==============================================================================

void Widget::on_apiKeyValue_returnPressed()
{
    // Update our user's information and Kanji (and therefore our wallpaper)

    mWaniKani.setApiKey(mGui->apiKeyValue->text());

    updateKanji(true);
}

//==============================================================================

void Widget::on_intervalSpinBox_valueChanged(int pInterval)
{
    // Update our timer's interval

    if (!mInitializing)
        updateInterval(pInterval);
}

//==============================================================================

void Widget::on_forceUpdateButton_clicked()
{
    // Update our Kanji (and therefore our wallpaper)

    updateKanji(true);
}

//==============================================================================

void Widget::on_fontComboBox_currentTextChanged(const QString &pFontName)
{
    Q_UNUSED(pFontName);

    // Force the update our wallpaper

    if (!mInitializing)
        updateWallpaper(true);
}

//==============================================================================

void Widget::on_boldFontCheckBox_clicked()
{
    // Force the update our wallpaper

    if (!mInitializing)
        updateWallpaper(true);
}

//==============================================================================

void Widget::on_italicsFontCheckBox_clicked()
{
    // Force the update our wallpaper

    if (!mInitializing)
        updateWallpaper(true);
}

//==============================================================================

void Widget::on_swapPushButton_clicked()
{
    // Swap the foreground and background colours, but leaving the alpha values
    // untouched

    for (int i = 1; i <= 6; ++i) {
        QPushButton *fgPushButton = qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, 1)->widget());
        QPushButton *bgPushButton = qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, 2)->widget());
        QRgb fgColor = mColors.value(fgPushButton);
        QRgb bgColor = mColors.value(bgPushButton);

        setPushButtonColor(fgPushButton, qRgba(qRed(bgColor), qGreen(bgColor), qBlue(bgColor), qAlpha(fgColor)));
        setPushButtonColor(bgPushButton, qRgba(qRed(fgColor), qGreen(fgColor), qBlue(fgColor), qAlpha(bgColor)));
    }

    updateSrsDistributionPalettes();

    updateWallpaper(true);
}

//==============================================================================

void Widget::on_resetAllPushButton_clicked(const bool &pRetrieveSettingsOnly)
{
    // Retrieve all of our settings after having reset some of them, if
    // requested

    QSettings settings;
    bool setWaniKaniApiKey = false;

    if (mInitializing) {
        mFileName = settings.value(SettingsFileName).toString();

        mGui->apiKeyValue->setText(settings.value(SettingsApiKey).toString());

        setWaniKaniApiKey = true;
    }

    if (!pRetrieveSettingsOnly) {
        mInitializing = true;

        settings.clear();
    }

    if (settings.value(SettingsCurrentKanji, true).toBool())
        mGui->currentKanjiRadioButton->setChecked(true);
    else
        mGui->allKanjiRadioButton->setChecked(true);

    mGui->intervalSpinBox->setValue(settings.value(SettingsInterval).toInt());

    static const QColor Colors[6][2] = { { "#606060", "#60808080"},
                                         { "#606060", "#60dd0093"},
                                         { "#606060", "#60882d9e"},
                                         { "#606060", "#60294ddb"},
                                         { "#606060", "#600093dd"},
                                         { "#606060", "#60fbc042"} };

    QString fontName = settings.value(SettingsFontName).toString();

    mGui->fontComboBox->setCurrentText(fontName);
    mGui->boldFontCheckBox->setChecked(settings.value(SettingsBoldFont).toBool());
    mGui->italicsFontCheckBox->setChecked(settings.value(SettingsItalicsFont).toBool());

    for (int i = 1; i <= 6; ++i) {
        for (int j = 1; j <= 2; ++j) {
            QPushButton *pushButton = qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, j)->widget());
            QRgb color = settings.value(SettingsColor.arg(i).arg(j), Colors[i-1][j-1].rgba()).toUInt();

            setPushButtonColor(pushButton, color);
        }
    }

    if (fontName.isEmpty()) {
#if defined(Q_OS_WIN)
        mGui->fontComboBox->setCurrentText("MS Mincho");
#elif defined(Q_OS_LINUX)
        mGui->fontComboBox->setCurrentText("Droid Sans Fallback");
#elif defined(Q_OS_MAC)
        mGui->fontComboBox->setCurrentText("Hiragino Mincho Pro");
#else
    #error Unsupported platform
#endif
    }

    if (setWaniKaniApiKey)
        mWaniKani.setApiKey(mGui->apiKeyValue->text());

    if (!pRetrieveSettingsOnly) {
        mInitializing = false;

        updateSrsDistributionPalettes();

        updateKanji(true);
    }
}

//==============================================================================

void Widget::on_closeToolButton_clicked()
{
    // Keep track of our settings

    QSettings settings;

    settings.setValue(SettingsFileName, mFileName);
    settings.setValue(SettingsApiKey, mGui->apiKeyValue->text());
    settings.setValue(SettingsCurrentKanji, mGui->currentKanjiRadioButton->isChecked());
    settings.setValue(SettingsInterval, mGui->intervalSpinBox->value());
    settings.setValue(SettingsFontName, mGui->fontComboBox->currentText());
    settings.setValue(SettingsBoldFont, mGui->boldFontCheckBox->isChecked());
    settings.setValue(SettingsItalicsFont, mGui->italicsFontCheckBox->isChecked());

    for (int i = 1; i <= 6; ++i) {
        for (int j = 1; j <= 2; ++j)
            settings.setValue(SettingsColor.arg(i).arg(j), mColors.value(qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, j)->widget())));
    }

    // Close ourselves

    qApp->quit();
}

//==============================================================================

void Widget::waniKaniUpdated()
{
    // Update the GUI based on our WaniKani information

    updateGravatar(mWaniKani.gravatar());
    updateSrsDistributionPalettes();

    mGui->userInformationValue->setText("<center>"
                                        "    <span style=\"font-size: 15px;\"><strong><a href=\"https://www.wanikani.com/community/people/"+mWaniKani.userName()+"\""+QString(LinkStyle)+">"+mWaniKani.userName()+"</a></strong> of Sect <strong>"+mWaniKani.title()+"</strong></span><br/>"
                                        "    <span style=\"font-size: 11px;\"><strong>Level "+mWaniKani.level()+"</strong></span>"
                                        "</center>");

    updateSrsDistributionInformation(mGui->apprenticeValue, ":/apprentice", mWaniKani.srsDistribution().apprentice());
    updateSrsDistributionInformation(mGui->guruValue, ":/guru", mWaniKani.srsDistribution().guru());
    updateSrsDistributionInformation(mGui->masterValue, ":/master", mWaniKani.srsDistribution().master());
    updateSrsDistributionInformation(mGui->enlightenedValue, ":/enlightened", mWaniKani.srsDistribution().enlightened());
    updateSrsDistributionInformation(mGui->burnedValue, ":/burned", mWaniKani.srsDistribution().burned());

    mGui->userInformationValue->show();
    mGui->apprenticeValue->show();
    mGui->guruValue->show();
    mGui->masterValue->show();
    mGui->enlightenedValue->show();
    mGui->burnedValue->show();
}

//==============================================================================

void Widget::waniKaniError()
{
    // Something went wrong, so hide a few things

    updateGravatar(QPixmap(":/warning"));

    mGui->userInformationValue->hide();
    mGui->apprenticeValue->hide();
    mGui->guruValue->hide();
    mGui->masterValue->hide();
    mGui->enlightenedValue->hide();
    mGui->burnedValue->hide();
}

//==============================================================================

void Widget::trayIconActivated(const QSystemTrayIcon::ActivationReason &pReason)
{
    Q_UNUSED(pReason);

    // Show ourselves in all cases by first making sure that we are in the
    // centre of the screen

    QDesktopWidget desktopWidget;
    QRect availableGeometry = desktopWidget.availableGeometry();

    move(availableGeometry.center()-QPoint(width() >> 1, height() >> 1));

    // Show ourselves

    show();

    // Note: to show ourselves, one would normally use activateWindow() (and
    //       possibly raise()), but depending on the operating system it may or
    //       not bring our widget to the foreground, so instead we do what
    //       follows, depending on the operating system...

#if defined(Q_OS_WIN)
    // Show ourselves the Windows way

    // Retrieve our window Id

    HWND mainWinId = reinterpret_cast<HWND>(winId());

    // Bring us to the foreground

    DWORD foregroundThreadProcId = GetWindowThreadProcessId(GetForegroundWindow(), 0);
    DWORD mainThreadProcId = GetWindowThreadProcessId(mainWinId, 0);

    if (foregroundThreadProcId != mainThreadProcId) {
        // Our thread process Id is not that of the foreground window, so attach
        // the foreground thread to ourselves, set ourselves to the foreground,
        // and detach the foreground thread from ourselves

        AttachThreadInput(foregroundThreadProcId, mainThreadProcId, true);

        SetForegroundWindow(mainWinId);
        SetFocus(mainWinId);

        AttachThreadInput(foregroundThreadProcId, mainThreadProcId, false);
    } else {
        // Our thread process Id is that of the foreground window, so just set
        // ourselves to the foreground

        SetForegroundWindow(mainWinId);
    }
#elif defined(Q_OS_LINUX) || defined(Q_OS_MAC)
    // We are on Linux or macOS, so we can simply activate the window and raise
    // ourselves

    activateWindow();
    raise();
#else
    #error Unsupported platform
#endif
}

//==============================================================================

void Widget::updateLevels()
{
    // Update the levels to display

    if (!mInitializing)
        updateKanji(true);
}

//==============================================================================

void Widget::updatePushButtonColor()
{
    // Update the background colour of the given push button

    QPushButton *pushButton = qobject_cast<QPushButton *>(sender());
    QColorDialog  colorDialog;

    colorDialog.setCurrentColor(pushButton->palette().color(QPalette::Button));
    colorDialog.setOption(QColorDialog::ShowAlphaChannel);

    if (colorDialog.exec() == QDialog::Accepted) {
        setPushButtonColor(pushButton, colorDialog.currentColor().rgba());

        updateSrsDistributionPalettes();

        updateWallpaper(true);
    }
}

//==============================================================================

void Widget::setPushButtonColor(QPushButton *pPushButton, const QRgb &pColor)
{
    // Set the background of the given push button to the given colour

    mColors.insert(pPushButton, pColor);

    pPushButton->setStyleSheet(QString("QPushButton#%1 {"
                                       "    border: 1px solid gray;"
                                       "    background-color: rgba(%2, %3, %4, %5);"
                                       "}").arg(pPushButton->objectName())
                                           .arg(qRed(pColor))
                                           .arg(qGreen(pColor))
                                           .arg(qBlue(pColor))
                                           .arg(qAlpha(pColor)));
}

//==============================================================================

void Widget::checkWallpaper()
{
    // Retrieve the file name of the current wallpaper

#if defined(Q_OS_WIN)
    WCHAR tempFileName[MAX_PATH];

    SystemParametersInfo(SPI_GETDESKWALLPAPER, sizeof(tempFileName),
                         tempFileName, 0);

    QString wallpaperFileName = QString::fromUtf16(reinterpret_cast<const ushort *>(tempFileName));
#elif defined(Q_OS_MAC)
    QString wallpaperFileName = QUrl(macosWallpaper()).toLocalFile();
#else
    QProcess process;

    process.start("gsettings",
                  QStringList() << "get"
                                << "org.gnome.desktop.background"
                                << "picture-uri");
    process.waitForFinished();

    QString tempFileName = QString(process.readAll()).trimmed();
    QString wallpaperFileName = QUrl(tempFileName.mid(1, tempFileName.length()-2)).toLocalFile();
#endif

    // Update our wallpaper, if the current wallpaper file name is not the same
    // as the one in our settings (which might happen if we switch virtual
    // desktops, for example)

    if (wallpaperFileName.compare(mFileName))
        setWallpaper();

    // Check again in about one second

    QTimer::singleShot(1000, this, SLOT(checkWallpaper()));
}

//==============================================================================
// End of file
//==============================================================================
