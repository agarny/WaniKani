/*******************************************************************************

Copyright Alan Garny

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*******************************************************************************/

//==============================================================================
// Widget
//==============================================================================

#include "widget.h"

//==============================================================================

#include <QBuffer>
#include <QColorDialog>
#include <QDate>
#include <QDesktopWidget>
#include <QDir>
#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>
#include <QKeyEvent>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QNetworkRequest>
#include <QPainter>
#include <QSettings>
#include <QStandardPaths>
#include <QTextStream>

//==============================================================================

#if defined(Q_OS_WIN)
    #include <Windows.h>
#elif defined(Q_OS_MAC)
    #include "macos.h"

    #include <math.h>
#else
    #include <QProcess>
#endif

//==============================================================================

#include "ui_widget.h"

//==============================================================================

ReviewsTimeLineWidget::ReviewsTimeLineWidget(QWidget *pParent) :
    QWidget(pParent)
{
    // Minimum and maximum sizes for our progress bar

    setMinimumSize(QSize(0, 150));
    setMaximumSize(QSize(16777215, 150));
}

//==============================================================================

void ReviewsTimeLineWidget::paintEvent(QPaintEvent *pEvent)
{
    // Paint ourselves

    QPainter painter(this);

    painter.fillRect(0, 0, width(), height(), QPalette().button());

    // Accept the event

    pEvent->accept();
}

//==============================================================================

ProgressBarWidget::ProgressBarWidget(QWidget *pParent) :
    QWidget(pParent),
    mValue(0.0),
    mColor(QPalette().highlight().color().rgba())
{
    // Minimum and maximum sizes for our progress bar

    setMinimumSize(QSize(0, 6));
    setMaximumSize(QSize(16777215, 6));
}

//==============================================================================

void ProgressBarWidget::paintEvent(QPaintEvent *pEvent)
{
    // Paint ourselves

    QPainter painter(this);

    int value = mValue*(width()-2);

    painter.setPen(QPalette().mid().color());
    painter.drawRect(0, 0, width()-1, height()-1);

    if (value) {
        QColor color;

        color.setRgba(mColor);

        painter.fillRect(1, 1, value, height()-2, color);
    }

    // Accept the event

    pEvent->accept();
}

//==============================================================================

void ProgressBarWidget::setValue(const double &pValue)
{
    // Update both our value and ourselves, if needed

    double value = qMin(1.0, qMax(pValue, 0.0));

    if (value != mValue) {
        bool needUpdate = int(mValue*width()) != int(value*width());

        mValue = value;

        if (needUpdate)
            update();
    }
}

//==============================================================================

void ProgressBarWidget::setColor(const QRgb &pColor)
{
    // Update our color, if needed

    if (pColor != mColor) {
        mColor = pColor;

        update();
    }
}

//==============================================================================

static const auto SettingsFileName     = QStringLiteral("FileName");
static const auto SettingsApiKey       = QStringLiteral("ApiKey");
static const auto SettingsCurrentKanji = QStringLiteral("CurrentKanji");
static const auto SettingsInterval     = QStringLiteral("Interval");
static const auto SettingsFontName     = QStringLiteral("FontName");
static const auto SettingsBoldFont     = QStringLiteral("BoldFont");
static const auto SettingsItalicsFont  = QStringLiteral("ItalicsFont");
static const auto SettingsColor        = QStringLiteral("Color%1%2");

//==============================================================================

static const auto LinkStyle = " style=\"color: rgb(103, 103, 103); outline: 0px; text-decoration: none;\"";

//==============================================================================

Widget::Widget() :
    mGui(new Ui::Widget),
    mInitializing(true),
    mFileName(QString()),
    mColors(QMap<QPushButton *, QRgb>()),
    mCurrentKanjiState(QMap<QChar, QString>()),
    mAllKanjiState(QMap<QChar, QString>()),
    mOldKanjiState(QMap<QChar, QString>()),
    mNeedToCheckWallpaper(true),
    mCurrentRadicalsReviews(Reviews()),
    mAllRadicalsReviews(Reviews()),
    mCurrentKanjiReviews(Reviews()),
    mAllKanjiReviews(Reviews()),
    mCurrentVocabularyReviews(Reviews()),
    mAllVocabularyReviews(Reviews())
{
    // Set up our GUI

    mGui->setupUi(this);

    mCurrentRadicalsProgress = new ProgressBarWidget(this);
    mCurrentKanjiProgress = new ProgressBarWidget(this);

    mGui->userInformationGroupBox->layout()->addWidget(mCurrentRadicalsProgress);
    mGui->userInformationGroupBox->layout()->addWidget(mCurrentKanjiProgress);

    mReviewsTimeLine = new ReviewsTimeLineWidget(this);

    mGui->layout->insertWidget(mGui->layout->indexOf(mGui->bottomSeparator), mReviewsTimeLine);

    setMinimumSize(0.8*QDesktopWidget().availableGeometry().size());

#ifdef Q_OS_MAC
    setWindowFlags(Qt::FramelessWindowHint);
#else
    setWindowFlags(Qt::Popup);
#endif

    connect(mGui->currentKanjiRadioButton, SIGNAL(clicked()),
            this, SLOT(updateLevels()));
    connect(mGui->allKanjiRadioButton, SIGNAL(clicked()),
            this, SLOT(updateLevels()));

    for (int i = 1; i <= 6; ++i) {
        for (int j = 1; j <= 2; ++j) {
            connect(qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, j)->widget()), SIGNAL(clicked()),
                    this, SLOT(updatePushButtonColor()));
        }
    }

#ifdef Q_OS_MAC
    mGui->apiKeyValue->setAttribute(Qt::WA_MacShowFocusRect, false);
    mGui->intervalSpinBox->setAttribute(Qt::WA_MacShowFocusRect, false);
#endif

    // Some about information

    static const QString About = "<span style=\"font-size: 19px;\"><strong><a href=\"https://github.com/agarny/wanikani\""+QString(LinkStyle)+">WaniKani</a> %1</strong></span><br/>"
                                 "Â© 2016%2 <a href=\"https://github.com/agarny\""+QString(LinkStyle)+">Alan Garny</a>";

    QFile versionFile(":/version");

    versionFile.open(QIODevice::ReadOnly);

    QTextStream stream(&versionFile);
    QString version = stream.readAll();

    versionFile.close();

    int currentYear = QDate::currentDate().year();

    mGui->aboutValue->setText(About.arg(version,
                                        (currentYear > 2016)?
                                            QString("-%1").arg(currentYear):
                                            QString()));

    // Handle signals from our WaniKani object

    connect(&mWaniKani, SIGNAL(updated()),
            this, SLOT(waniKaniUpdated()));
    connect(&mWaniKani, SIGNAL(error()),
            this, SLOT(waniKaniError()));

    // Retrieve our settings

    retrieveSettings();

    // Use our timer to update our WaniKani object

    connect(&mTimer, SIGNAL(timeout()),
            &mWaniKani, SLOT(update()));

    updateInterval(mGui->intervalSpinBox->value());

    // Create and show our system tray icon

    mTrayIcon.setIcon(QIcon(":/icon"));
    mTrayIcon.setToolTip("WaniKani");

    connect(&mTrayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)),
            this, SLOT(trayIconActivated()));

    mTrayIcon.show();

    mInitializing = false;
}

//==============================================================================

#ifdef Q_OS_MAC
void Widget::keyPressEvent(QKeyEvent *pEvent)
{
    // Hide ourselves if the user presses the escape key

    if (pEvent->key() == Qt::Key_Escape)
        hide();
    else
        QWidget::keyPressEvent(pEvent);
}
#endif

//==============================================================================

void Widget::retrieveSettings(const bool &pResetSettings)
{
    // Retrieve all of our settings after having reset some of them, if
    // requested

    QSettings settings;
    bool setWaniKaniApiKey = false;

    if (mInitializing) {
        mFileName = settings.value(SettingsFileName).toString();

        mGui->apiKeyValue->setText(settings.value(SettingsApiKey).toString());

        setWaniKaniApiKey = true;
    }

    if (pResetSettings) {
        mInitializing = true;

        settings.clear();
    }

    if (settings.value(SettingsCurrentKanji, true).toBool())
        mGui->currentKanjiRadioButton->setChecked(true);
    else
        mGui->allKanjiRadioButton->setChecked(true);

    mGui->intervalSpinBox->setValue(settings.value(SettingsInterval).toInt());

    static const QColor Colors[6][2] = { { "#606060", "#60808080"},
                                         { "#606060", "#60dd0093"},
                                         { "#606060", "#60882d9e"},
                                         { "#606060", "#60294ddb"},
                                         { "#606060", "#600093dd"},
                                         { "#606060", "#60fbc042"} };

    QString fontName = settings.value(SettingsFontName).toString();

    mGui->fontComboBox->setCurrentText(fontName);
    mGui->boldFontCheckBox->setChecked(settings.value(SettingsBoldFont).toBool());
    mGui->italicsFontCheckBox->setChecked(settings.value(SettingsItalicsFont).toBool());

    for (int i = 1; i <= 6; ++i) {
        for (int j = 1; j <= 2; ++j) {
            QPushButton *pushButton = qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, j)->widget());
            QRgb color = settings.value(SettingsColor.arg(i).arg(j), Colors[i-1][j-1].rgba()).toUInt();

            setPushButtonColor(pushButton, color);
        }
    }

    if (fontName.isEmpty()) {
#if defined(Q_OS_WIN)
        mGui->fontComboBox->setCurrentText("MS Mincho");
#elif defined(Q_OS_LINUX)
        mGui->fontComboBox->setCurrentText("Droid Sans Fallback");
#elif defined(Q_OS_MAC)
        mGui->fontComboBox->setCurrentText("Hiragino Mincho Pro");
#else
    #error Unsupported platform
#endif
    }

    if (setWaniKaniApiKey)
        mWaniKani.setApiKey(mGui->apiKeyValue->text());

    if (pResetSettings) {
        mInitializing = false;

        updateSrsDistributionPalettes();

        updateWallpaper(true);
    }
}

//==============================================================================

void Widget::updateInterval(const int &pInterval)
{
    // Update our timer's interval

    mTimer.start(60000*pInterval);
}

//==============================================================================

QString Widget::iconDataUri(const QString &pIcon, const int &pWidth,
                            const int &pHeight, const QIcon::Mode &pMode)
{
    // Convert an icon, which resource name is given, to a data URI, after
    // having resized it, if requested

    QIcon icon(pIcon);

    if (icon.isNull())
        return QString();

    QByteArray data;
    QBuffer buffer(&data);
    QSize iconSize = icon.availableSizes().first();

    buffer.open(QIODevice::WriteOnly);
    icon.pixmap((pWidth == -1)?iconSize.width():pWidth,
                (pHeight == -1)?iconSize.height():pHeight,
                pMode).save(&buffer, "PNG");

    return QString("data:image/png;base64,%1").arg(QString(data.toBase64()));
}

//==============================================================================

void Widget::updateGravatar(const QPixmap &pGravatar)
{
    // Update our gravatar

    mGui->gravatarValue->setPixmap(pGravatar.scaled(80, 80, Qt::KeepAspectRatio, Qt::SmoothTransformation));
}

//==============================================================================

void Widget::updateSrsDistributionPalettes()
{
    // Update the palette of our different SRS distribution information

    QPalette palette;

    palette.setColor(QPalette::Window, mGui->apprenticeBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->apprenticeForegroundPushButton->palette().color(QPalette::Button));

    mGui->apprenticeValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->guruBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->guruForegroundPushButton->palette().color(QPalette::Button));

    mGui->guruValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->masterBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->masterForegroundPushButton->palette().color(QPalette::Button));

    mGui->masterValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->enlightenedBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->enlightenedForegroundPushButton->palette().color(QPalette::Button));

    mGui->enlightenedValue->setPalette(palette);

    palette.setColor(QPalette::Window, mGui->burnedBackgroundPushButton->palette().color(QPalette::Button));
    palette.setColor(QPalette::WindowText, mGui->burnedForegroundPushButton->palette().color(QPalette::Button));

    mGui->burnedValue->setPalette(palette);
}

//==============================================================================

void Widget::updateSrsDistributionInformation(QLabel *pLabel,
                                              const QString &pIcon,
                                              const SrsDistributionInformation &pInformation)
{
    // Update the given SRS distribution information

    pLabel->setText("<img src=\""+iconDataUri(pIcon, 32, 32)+"\"><br/>"+pInformation.total());
    pLabel->setToolTip("<center>\n"
                       "    <strong>"+pInformation.name()+"</strong>\n"
                       "</center>\n"
                       "<table>\n"
                       "    <tbody>\n"
                       "        <tr>\n"
                       "            <td>Radicals:</td>\n"
                       "            <td style=\"width: 4px;\"></td>\n"
                       "            <td align=center>"+pInformation.radicals()+"</td>\n"
                       "        </tr>\n"
                       "        <tr>\n"
                       "            <td>Kanji:</td>\n"
                       "            <td style=\"width: 4px;\"></td>\n"
                       "            <td align=center>"+pInformation.kanji()+"</td>\n"
                       "        </tr>\n"
                       "        <tr>\n"
                       "            <td>Vocabulary:</td>\n"
                       "            <td style=\"width: 4px;\"></td>\n"
                       "            <td align=center>"+pInformation.vocabulary()+"</td>\n"
                       "        </tr>\n"
                       "    </tbody>\n"
                       "</table>\n");
}

//==============================================================================

QJsonDocument Widget::waniKaniRequest(const QString &pRequest)
{
    // Make sure that we have an API key

    if (mGui->apiKeyValue->text().isEmpty())
        return QJsonDocument();

    // Send a request to WaniKani and convert its response to a JSON document,
    // if possible

    QNetworkAccessManager networkAccessManager;
    QNetworkReply *networkReply = networkAccessManager.get(QNetworkRequest(QString("https://www.wanikani.com/api/v1/user/%1/%2").arg(mGui->apiKeyValue->text(), pRequest)));
    QEventLoop eventLoop;

    QObject::connect(networkReply, SIGNAL(finished()),
                     &eventLoop, SLOT(quit()));

    eventLoop.exec();

    QByteArray response = QByteArray();

    if (networkReply->error() == QNetworkReply::NoError)
        response = networkReply->readAll();

    networkReply->deleteLater();

    if (response.isEmpty())
        return QJsonDocument();
    else
        return QJsonDocument::fromJson(response);
}

//==============================================================================

static const QString KanjiTable =
"ä¸äºä¸åäºå­ä¸å«ä¹åå£æ¥æç°ç®å¤å¾åææå±æ¶ååææ©æ­ä¸èæ¦èäºå¹å¸æ§èªç½ç¾ä¸­åèåæä¸¸å¯¸å°å"
"å ä¸ä¸åæåªè²è²å¡è¦ååé é å¡è² ä¸å¥èæ¬åºçé¦ä¹ä¹±ç´å·çå·¥å·¦å³æè³è²¢é åååå¬æ­åå¯å¥ä¸çºå¯é "
"å­å­äºå¥³å¥½å¦æ¯è²«ååå°å°å¤§å¤å¤æ±å¤åç³èç¡ç ç ååå¤ªå¨è­å¦çåå¥å·å·é æ°´æ°·æ°¸æ³åé¡æ³³æ²¼æ²æ±æ±æ½®"
"æºæ´»æ¶æ³æ²³æ³æ¹æ¸¬ååå§å¼å£å­å°æ¶¯å¯ºæåç«çç©æ·¡ç¯çç½ç°ç¹ç§é­æ¼éé»å¢¨é¯éåååæ´è´åå°å­å®å®å®£"
"å®µå®å®´å¯å¯è²¯æ¨ææ£®æ¡ææ æ¢¢æ£ææ¡æ¤æ¯æ´æç¸æºæ¬æ­æ¦æ¡ç¥æªæ«æ²«å³å¦¹æ±æ ªè¥èè¦å¯èèæ¨¡æ¼ å¢æ®èèå"
"æ¡çºç¬ç¶é»ç¶è»ç©ç«çç¹ååæ´ä»çè¶åå¡ççå®ç ç¾ççåå¨æ çä¸»æ³¨æ±ééé¢éé£ééé®éå°è¾»è¿é è¿«"
"éè¾ºå·¡è»é£è»è¼¸ååæ ¼ç¥å®¢é¡å¤å¦æ¡è½åè»è¼éå å¤¢åé«äº«å¡¾çäº­äº¬æ¶¼æ¯é¯¨èå¨é±å£«åå£®èå£²å­¦è¦æ æ¸æ´¥ç§"
"æ»ææææ¬è¨è­¦è¨çè¨è¨è¨è©è©°è©±è© è©©èªèª­èª¿è«è«¾è«­å¼è©¦å¼åè³æ ½è¼èæåèª å¨æ»æ¸æ¡é­æµæ­¢æ­©æ¸é »è¯ä¼æ­´"
"æ­¦è³¦æ­£è¨¼æ¿å®é èµ°è¶èµ´è¶æ¯é¡å ¤å»ºå»¶èªç¤å©¿è¡£è£è£è£å£åé ç¿åå¸å¸å¹å¸½å¹å¹é¦å¸å§èºå¸¯æ»åºå¶è£½è»¢è¸é¨é²"
"æé·éå¬å¤©æ©å¬ç«æ³£ç« ç«¶å¸ç«¥ç³éåå«¡é©æ»´æµååèæ¯æçæ··æ¸è¬è¤åæ¨èå£±æ¯ææ¢æµ·ä¹ä¹¾è¹è¤æ¬ å¹çæ­è»"
"æ¬¡è¨è³å§¿è«®è³ å¹åé³æé»è­é¡å¢äº¡ç²å¦èææ¹å¦¨åè³èªè¨ªæ¾æ¿è±èª¬é­æ½å¢è´æ±æ£åå¦å»·æçè³æ­³çæ å°æ± è«"
"èèè¹è¶ç¬èé¢¨å·±èµ·å¦æ¹è¨åèç ²æ³¡äºé»ç«æ»è±ééå®¶å«è±ªè¸å ´æ¹¯ç¾ç¾æ´è©³é®®éç¾¨å·®çå¯ç¦ç¤éåé²ééæº"
"å¥®å¥ªç¢ºåè¨±æ­æ¨©è¦³ç¾½ç¿ç¿ææ¿¯æ°å°åºå½å£å å§»ååå£åºåº«åº­åºåºéº»ç£¨å¿å¿å¿èªå¿å¿èªå¿ ä¸²æ£ææ©å¿ææ³æ¯æ©"
"æµææææå¯¡å¿æ¦ææ¼ææææææ£ææ°ææ¾æ¶ææ·»å¿æ³æçæ©æç¾©è­°ç æ¹æ±æ­æææ¹ææææææ¨æææ"
"æææ¬æ®æ¨ææææ¾ææ æææ¥æ²æç ææ¢°é¼»ååæè²¡æå­å¨ä¹æºåå¸æ±ä¸å²åæ´ç¡¬ååæ¡é»è­·ç²å¥´æåæ"
"ææ²¡è¨­ææ®»æ¯ææè¢èæªè»½åç£å¯æ·ååæ¿è¿è²©çªå¦¥ä¹³æµ®å°å¥¨æ¡èåæææåºæ¡é±å¼éå°æ æ²»å§èçªå»æ³ä¼"
"è³å®¤å°è´äºæ£è²æ¤åéç¡«æµåååºå±±æå²©ç­å²å³ å´©å¯èåµå´å¥è¾¼åè²§é å¬æ¾ç¿è¨è°·æµ´å®¹æº¶æ¬²è£éæ²¿è³åå å¸¸"
"è£³æç®æ³¢å©æ«ç ´è¢«æ®æ®æ®æ®åè£çæ­»è¬ç¬è³åè¶£ææ®æ¥è·èæ¢è´ææ¢æ¼«è²·ç½®ç½°å¯§æ¿ç°éå¤«æ¶æ¸è¦æ¿è³æ½å¤±é"
"è¿­è£å§«èµèè³¢å è¨è¦§å·¨æåç·å´åå£åå§åªå±å è³æ¶èèåè¡å¾å¾©å¾å¾å¾å¾å¾å¾å¾å½¼å½¹å¾³å¾¹å¾´æ²å¾®è¡è¡¡ç¨¿ç¨¼"
"ç¨ç¨ç¨åç§»ç§ç§æç§ç§©ç§ç§°å©æ¢¨ç©«ç©ç¨²é¦å­£å§ç§éèªç©èç±³ç²ç²ç²ç²§è¿·ç²ç³§èå¥¥æ°æ¥¼é¡æ¼æ§æ±çæç«¹ç¬ç¬ ç¬¹"
"ç­ç®±ç­ç­ç­ç®ç­ç­ç°¿ç¯äººä½ä½ä½ä½ä»²ä½æ ä»¶ä»ä»ä¼ä¼ä»ä¼ä»®ä¼¯ä¿ä¿¡ä½³ä¾ä¾åå¥å´ä¾åå¤å£ååµå§åååä»å¬"
"ä»ä¾®ä½¿ä¾¿ååªä¼å®¿å·ä¿è¤åä»ç¬¦åºä»»è³ä»£è¢è²¸åè±è²¨å¾ä½è·ä¿åä¹çååä¸æèèåº§åååä»¥ä¼¼ä½µç¦ç¶å®®å¶"
"åå¹´å¤æ¶²å¡å¹£å¼åæèæ½æéæå¿ç©æè³å°¿å°¼å°»æ³¥å¡å±¥å±æ¡å±æå å±æ®å±¤å±éæ¼å·å°ºå°½æ²¢è¨³ææ¼æ¸è©æ¿æç"
"æ»æ¶éé¡§åç¤ºç¤¼ç¥¥ç¥ç¦ç¥ç¤¾è¦å¥å°æ°æ¬¾ç¦è¥å®å´ç¥­å¯æ¦ç±æ½æ²¹è¢å®å±ç¬è»¸ç²æ¼å²¬æ¿ç³ä¼¸ç¥ææèèª²è£¸æ¤ææ"
"ç¥è¿æå²éèªæ«æ¼¸æ­è³ªæ¥è¨´æ¨è©ä½éªé²å°æ¥ç©ä¾µæµ¸å¯å©¦æå½äºæµäºåç³åº·é®ä¼åç¾¤èéåç«¯ä¸¡æºç»æ­¯æ²æ¹é­"
"æ¼æ§½ææç§å³ç¨åº¸åæé¯åææªæ£å»¿åº¶é®å¸­åº¦æ¸¡å¥å´å¢³æ¤ç¼æåä¼´çå¤å¸å·»ååè¤è¬ççä¹ä¹èä¸å¦æ¯ç¢ç¯"
"æç¥æºçæåé§ç­å¸°å¼å¼å¼å¼å¼·å¼±æ²¸è²»ç¬¬å¼å·§å·æ½èªæ±ä¸åèº«å°è¬èèå­ææ·èç®èç½²æè«¸çªæ¸è³­å³¡ç­æè¿½"
"å¸«å¸¥å®æ£ºç®¡ç¶äº¤å¹è¼æ ¡è¶³ä¿è·è·¯é²è·³èºè·µè¸éª¨æ»é«ç¦æ¸¦ééªé¿ééééªé½é³é²éé¢é£éå¢éééé£éé å é¥"
"ç©´ç©ºæ§çªç©¶çªçªçªªæ¾çª¯çª®æ¢æ·±ä¸å²³åµæµç³¸ç¹ç¹ç¸®ç¹ç¸¦ç·ç· ç¶­ç¾ç·´ç·ç¶çµµçµ±çµçµ¦çµ¡çµçµç´ç´ç´ç´ç´¡ç´ç´¹çµç´³ç´"
"ç´°ç´¯ç´¢ç·ç¶¿çµ¹ç¹°ç¶ç·ç¸ç¶²ç·ç´«ç¸ç¸å¹¼å¾å¹½å¹¾æ©ççèå¼¦ææ»æç£ç³»ä¿å­«æ¸å´èå¸å¾¡æå½ä»¤é¶é½¢å·é é´åéè¸"
"çæ¬åç¯ç¯åå±å®èèæ¨æ³åµçè²¿å°èééééµé·é¬éªé¢ééé¸ç¶å°è±é ­ç­è±é¼åæ¨¹ç¿è¡çççæ¸©ç£æ¿«éç"
"çå¡©éæ¨æ ¹å³çµç¯ééç¼è¯ææµªå¨é£é£¯é£²é£¢é¤é£¾é¤¨é¤é£½æ¢æ¦æ¨å¹³å¼åªè©åå¸å¶è¸é¢æ®ºç´éè¾è¾æ¢å®°å£é¿æ°èª"
"è¦ªå¹¸å·å ±å«ç³¾ååç¢é¸ç¦å¢ç±è±éµäº¥æ ¸å»è©²å¾è¿°è¡å¯é¸è­²å£å¬¢æ¯ç´ éº¦éç²¾è«ææ´æ¸éè²¬ç¸¾ç©åµæ¼¬è¡¨ä¿µæ½å¥å«"
"å®³è½å²æ²çæå§æ§ç²ç£éå³°ç¸«æå¯¿é³ç±æ¥æ¤¿æ³°å¥å®å¥ä¿¸æ£è¬¹å¤æ¼¢åé£è¯åç¡éä¹å°ä»å«åå¿µç´é°äºåºé éå¼"
"å«éè¬å»è¥¿ä¾¡è¦è°ç¥¨æ¼æ¨æ é·è¦çåæ¥ ç®éåé²é¥éç°¡ééé£éèæ½¤æ¬éååµéä¿³ææ²ç½ªè¼©æä¾¯åæ±ºå¿«åé"
"ç·¯è¡éå¹²èåæ±è»å²¸å¹¹èå®ä½é¤å¾åéæå¡æé ¼ç¬åçéæ´å£éºæ¤å¹éåå²åç¨®è¡è«çç´ççç¾ç¢ç²ç«çç"
"å¿å å»å¹åºæ¢æ®´æ¬§æä»°è¿ç»æ¾çºå»åå¯®çå½«å½¢å½±æå½©å½°å½¦é¡é è¨åæ¨ä¿®çè¨ºæå¯¾ç´èæå¤æ¸æç²å¡æ¥½è¬çæ¸"
"æå¤®è±æ èµ¤èµ¦å¤è·¡è®ææ¹¾é»æ¨ªæè²çµ¶è¶è¥çç´ºæè¬åªæ¬ºæ£ææç¢åºçåå ªè²´éºé£èç¡çµç²ç§ç¥é»æ»å©å®ç³ä¸¦"
"æ®è­æ¹¿é¡ç¹éæ¥­æ²åå±ä¾ç°ç¿¼æ´ªæ¸¯æ´çæ­é¸æ®¿äºå²èäºæªåè§è§¦è§£åè¬è³¼æ§æºè«å«è¼ªåéç·¨åå¸æ°ç´å©ä½æµ"
"åºæ°ç ææµ¦è²èè£é¸é­é¡éé¨é½éµé¦é·é¿éå»ç¾å¾ªæ´¾èè¡éæ®µéåå¹»å¸ä¼ºè©é£¼å£èè¶èªè¬ç¤æ¬è¹è¦èçå¼§å­¤"
"ç¹­çææ·æ¥æ°æ±½é£æ²å¦»è¡°è¡·é¢é©é´è¦å£°åå¨¯èª¤è¸æ¿å½æ¥µçè½éªééçªå¯©ç¿»è©æ¯èå°¾å®è¨çºå½é·å¼µå¸³è¹é«ªå±åª"
"å·£åæ¦ç¦å¼¾æ¡ç£è³æ©å³éæèªçé³¥é³´é¶´çè¦é³©é¶å³¶æåªæ´ç·©å±å±å¶éæééå¡å²¡é¼ç¶±åç¼¶é¶æºè¬¡å°±æå¢¾åé¸"
"æ©åè±¡åé¦¬é§é¨é¨é§é§é§é¨é§é©ç¯¤é¨°èèèèæ¯èæ®åèé¹¿è¦æ¶éºçè½æå¯æ¼è¾°è¾±éæ¯å¨ åè¾²æ¿éé¢å²é¬¼é"
"é­é­é­å¡è¥²åæé°ç®é¬éµç½·å±¯ä¸è»é·çä¸¹æ½ä¸å¯å·³è¬æ¤ç¿è´è¯éä¿ºéæç¶ºéé¤ä¸¼è³ä¼æå¢èæ³éçåèª°åªä¹"
"é å±æ¬éµå·¾ç½éåºç­å´ç®¸æ·å °é°éè²¼è¹é¬±ã";

//==============================================================================

void Widget::updateWallpaper(const bool &pForceUpdate)
{
    // Generate and set the wallpaper, if needed

    QMap<QChar, QString> kanjiState = mGui->currentKanjiRadioButton->isChecked()?mCurrentKanjiState:mAllKanjiState;

    if (   !kanjiState.isEmpty()
        &&  (pForceUpdate || (kanjiState != mOldKanjiState))) {
        // Keep track our needed Kanji

        mOldKanjiState = kanjiState;

        // Default wallpaper

        QPixmap pixmap;

        pixmap.load(":/wallpaper");

        // Generate the wallpaper

        static const int LeftBorder = 1240;
        static const int Shift = 32;
        static const int SmallShift = 1;

        QDesktopWidget desktopWidget;
        QRect availableGeometry = desktopWidget.availableGeometry();
        QRect geometry = desktopWidget.geometry();

        int areaWidth = pixmap.width()-LeftBorder-2*Shift;
        int areaHeight = double(availableGeometry.height())/geometry.height()*pixmap.height()-2*Shift;

        QFont font = QFont(mGui->fontComboBox->currentText());

        font.setBold(mGui->boldFontCheckBox->isChecked());
        font.setItalic(mGui->italicsFontCheckBox->isChecked());

        int fontPixelSize = 1;
        int charWidth = 0;
        int charHeight = 0;
        int nbOfRows = 0;
        int nbOfCols = 0;
        int descent = 0;

        forever {
            font.setPixelSize(fontPixelSize);

            QFontMetrics fontMetrics(font);
            int crtCharWidth = fontMetrics.width(KanjiTable.at(0));
            int crtCharHeight = fontMetrics.height();
            int crtNbOfCols = areaWidth/(crtCharWidth+SmallShift);
            int crtNbOfRows =  floor(kanjiState.size()/crtNbOfCols)
                              +((kanjiState.size() % crtNbOfCols)?1:0);

            if (crtNbOfRows*crtCharHeight+(crtNbOfRows-1)*SmallShift+fontMetrics.descent() <= areaHeight) {
                charWidth = crtCharWidth;
                charHeight = crtCharHeight;

                nbOfRows = crtNbOfRows;
                nbOfCols = crtNbOfCols;

                descent = fontMetrics.descent();

                ++fontPixelSize;
            } else {
                font.setPixelSize(fontPixelSize-1);

                break;
            }
        }

        QPainter painter(&pixmap);

        painter.setFont(font);

        int xStart = LeftBorder+Shift+((areaWidth-nbOfCols*charWidth-(nbOfCols-1)*SmallShift) >> 1);
        int x = 0;
        int y =  double(availableGeometry.top())/geometry.height()*pixmap.height()
                +Shift+((areaHeight-nbOfRows*charHeight-(nbOfRows-1)*SmallShift) >> 1)-descent;
        int radius = ceil(0.75*(qMax(charWidth, charHeight) >> 3));

        for (int i = 0, j = 0, iMax = KanjiTable.size(); i < iMax; ++i) {
            if (kanjiState.keys().contains(KanjiTable.at(i))) {
                if (!(j % nbOfCols)) {
                    x = xStart;
                    y += charHeight+(j?SmallShift:0);
                }

                QString state = kanjiState.value(KanjiTable.at(i));
                QColor foregroundColor;
                QColor backgroundColor;

                if (!state.compare("apprentice")) {
                    foregroundColor = color(2, 1);
                    backgroundColor = color(2, 2);
                } else if (!state.compare("guru")) {
                    foregroundColor = color(3, 1);
                    backgroundColor = color(3, 2);
                } else if (!state.compare("master")) {
                    foregroundColor = color(4, 1);
                    backgroundColor = color(4, 2);
                } else if (!state.compare("enlighten")) {
                    foregroundColor = color(5, 1);
                    backgroundColor = color(5, 2);
                } else if (!state.compare("burned")) {
                    foregroundColor = color(6, 1);
                    backgroundColor = color(6, 2);
                } else {
                    foregroundColor = color(1, 1);
                    backgroundColor = color(1, 2);
                }

                painter.setPen(foregroundColor);

                QPainterPath path;

                path.addRoundedRect(QRectF(x, y-charHeight+descent, charWidth, charHeight),
                                    radius, radius);

                painter.fillPath(path, QColor(backgroundColor));
                painter.drawText(x, y, KanjiTable.at(i));

                x += charWidth+SmallShift;

                ++j;
            }
        }

        // Delete our old wallpaper and save our new one before setting it

        if (!mFileName.isEmpty())
            QFile(mFileName).remove();

        mFileName = QDir::toNativeSeparators(QStandardPaths::writableLocation(QStandardPaths::PicturesLocation)+QDir::separator()+QString("WaniKani%1.jpg").arg(QDateTime::currentMSecsSinceEpoch()));

        pixmap.save(mFileName);

        setWallpaper();
    }

    // Ask for a wallpaper to be checked in about one second, if necessary

    if (mNeedToCheckWallpaper) {
        mNeedToCheckWallpaper = false;

        QTimer::singleShot(1000, this, SLOT(checkWallpaper()));
    }
}

//==============================================================================

void Widget::setWallpaper()
{
    // Set the new wallpaper

#if defined(Q_OS_WIN)
    SystemParametersInfo(SPI_SETDESKWALLPAPER, 0,
                         PVOID(mFileName.utf16()), SPIF_UPDATEINIFILE);
#elif defined(Q_OS_MAC)
    setMacosWallpaper(qPrintable(mFileName));
#else
    QProcess process;

    process.start("gsettings",
                  QStringList() << "set"
                                << "org.gnome.desktop.background"
                                << "picture-options"
                                << "stretched");
    process.waitForFinished();

    process.start("gsettings",
                  QStringList() << "set"
                                << "org.gnome.desktop.background"
                                << "picture-uri"
                                << QUrl::fromLocalFile(mFileName).toString());
    process.waitForFinished();
#endif
}

//==============================================================================

QColor Widget::color(const int &pRow, const int &pColumn) const
{
    // Return whether our font is to be in italics

    QRgb rgba = mColors.value(qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(pRow, pColumn)->widget()));

    return QColor(qRed(rgba), qGreen(rgba), qBlue(rgba), qAlpha(rgba));
}

//==============================================================================

void Widget::on_apiKeyValue_returnPressed()
{
    // Set our WaniKani API key

    mWaniKani.setApiKey(mGui->apiKeyValue->text());
}

//==============================================================================

void Widget::on_intervalSpinBox_valueChanged(int pInterval)
{
    // Update our timer's interval

    if (!mInitializing)
        updateInterval(pInterval);
}

//==============================================================================

void Widget::on_forceUpdateButton_clicked()
{
    // Update our WaniKani object

    mWaniKani.update();
}

//==============================================================================

void Widget::on_fontComboBox_currentTextChanged(const QString &pFontName)
{
    Q_UNUSED(pFontName);

    // Force the update of our wallpaper

    if (!mInitializing)
        updateWallpaper(true);
}

//==============================================================================

void Widget::on_boldFontCheckBox_clicked()
{
    // Force the update of our wallpaper

    if (!mInitializing)
        updateWallpaper(true);
}

//==============================================================================

void Widget::on_italicsFontCheckBox_clicked()
{
    // Force the update of our wallpaper

    if (!mInitializing)
        updateWallpaper(true);
}

//==============================================================================

void Widget::on_swapPushButton_clicked()
{
    // Swap the foreground and background colours, but leaving the alpha values
    // untouched

    for (int i = 1; i <= 6; ++i) {
        QPushButton *fgPushButton = qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, 1)->widget());
        QPushButton *bgPushButton = qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, 2)->widget());
        QRgb fgColor = mColors.value(fgPushButton);
        QRgb bgColor = mColors.value(bgPushButton);

        setPushButtonColor(fgPushButton, qRgba(qRed(bgColor), qGreen(bgColor), qBlue(bgColor), qAlpha(fgColor)));
        setPushButtonColor(bgPushButton, qRgba(qRed(fgColor), qGreen(fgColor), qBlue(fgColor), qAlpha(bgColor)));
    }

    updateSrsDistributionPalettes();

    updateWallpaper(true);
}

//==============================================================================

void Widget::on_resetAllPushButton_clicked()
{
    // Retrieve all of our settings after having reset some of them

    retrieveSettings(true);
}

//==============================================================================

void Widget::on_closeToolButton_clicked()
{
    // Keep track of our settings

    QSettings settings;

    settings.setValue(SettingsFileName, mFileName);
    settings.setValue(SettingsApiKey, mGui->apiKeyValue->text());
    settings.setValue(SettingsCurrentKanji, mGui->currentKanjiRadioButton->isChecked());
    settings.setValue(SettingsInterval, mGui->intervalSpinBox->value());
    settings.setValue(SettingsFontName, mGui->fontComboBox->currentText());
    settings.setValue(SettingsBoldFont, mGui->boldFontCheckBox->isChecked());
    settings.setValue(SettingsItalicsFont, mGui->italicsFontCheckBox->isChecked());

    for (int i = 1; i <= 6; ++i) {
        for (int j = 1; j <= 2; ++j)
            settings.setValue(SettingsColor.arg(i).arg(j), mColors.value(qobject_cast<QPushButton *>(qobject_cast<QGridLayout *>(mGui->colorsLayout)->itemAtPosition(i, j)->widget())));
    }

    // Close ourselves

    qApp->quit();
}

//==============================================================================

QString Widget::timeToString(const int &pSeconds)
{
    // Return the given number of seconds as a formatted string

    if (pSeconds < 60) {
        return "less than 1 minute";
    } else {
        QString res = QString();
        int weeks = pSeconds/604800;
        int days = (pSeconds/86400)%7;
        int hours = (pSeconds/3600)%24;
        int minutes = (pSeconds/60)%60;

        if (weeks)
            res += (weeks == 1)?"1 week":QString("%1 weeks").arg(weeks);

        if (days) {
            if (!res.isEmpty())
                res += ", ";

            res += (days == 1)?"1 day":QString("%1 days").arg(days);
        }

        if (hours) {
            if (!res.isEmpty())
                res += ", ";

            res += (hours == 1)?"1 hour":QString("%1 hours").arg(hours);
        }

        if (minutes) {
            if (!res.isEmpty())
                res += ", ";

            res += (minutes == 1)?"1 minute":QString("%1 minutes").arg(minutes);
        }

        int lastCommaPosition = res.lastIndexOf(',');

        if (lastCommaPosition == -1)
            return res;
        else
            return res.left(lastCommaPosition)+" and"+res.right(res.length()-lastCommaPosition-1);
    }
}

//==============================================================================

void Widget::determineReviews(const Reviews &pCurrentReviews,
                              const Reviews &pAllReviews, const QDateTime &pNow,
                              QDateTime &pNextDateTime, int &pDiff,
                              int *pNbOfReviews)
{
    // Determine all the given reviews

    foreach (const QDateTime &dateTime, pAllReviews.keys()) {
        int localDiff = pNow.secsTo(dateTime);

        if (localDiff < pDiff) {
            pDiff = localDiff;

            pNextDateTime = dateTime;
        }

        int currentReviews = pCurrentReviews.value(dateTime);
        int allReviews = pAllReviews.value(dateTime);

        if (localDiff <= 0) {
            pNbOfReviews[0] += currentReviews;
            pNbOfReviews[1] += allReviews;
        }

        if (localDiff < 3600) {
            pNbOfReviews[2] += currentReviews;
            pNbOfReviews[3] += allReviews;
        }

        if (localDiff < 86400) {
            pNbOfReviews[4] += currentReviews;
            pNbOfReviews[5] += allReviews;
        }
    }
}

//==============================================================================

void Widget::waniKaniUpdated()
{
    // Retrieve the user's gravatar

    QNetworkAccessManager networkAccessManager;
    QNetworkReply *networkReply = networkAccessManager.get(QNetworkRequest("https://www.gravatar.com/avatar/"+mWaniKani.gravatar()));
    QEventLoop eventLoop;

    QObject::connect(networkReply, SIGNAL(finished()),
                     &eventLoop, SLOT(quit()));

    eventLoop.exec();

    QByteArray gravatarData = QByteArray();

    if (networkReply->error() == QNetworkReply::NoError)
        gravatarData = networkReply->readAll();

    networkReply->deleteLater();

    QPixmap gravatar;

    if (gravatarData.isEmpty())
        gravatar = QPixmap(":/face");
    else
        gravatar.loadFromData(gravatarData);

    // Update the GUI based on our WaniKani information

    updateGravatar(gravatar);
    updateSrsDistributionPalettes();

    mGui->userInformationValue->setText("<center>\n"
                                        "    <span style=\"font-size: 15px;\"><strong><a href=\"https://www.wanikani.com/community/people/"+mWaniKani.userName()+"\""+QString(LinkStyle)+">"+mWaniKani.userName()+"</a></strong> of Sect <strong>"+mWaniKani.title()+"</strong></span><br/>\n"
                                        "    <span style=\"font-size: 11px;\"><strong>Level "+QString::number(mWaniKani.level())+"</strong></span>\n"
                                        "</center>\n");

    updateSrsDistributionInformation(mGui->apprenticeValue, ":/apprentice", mWaniKani.srsDistribution().apprentice());
    updateSrsDistributionInformation(mGui->guruValue, ":/guru", mWaniKani.srsDistribution().guru());
    updateSrsDistributionInformation(mGui->masterValue, ":/master", mWaniKani.srsDistribution().master());
    updateSrsDistributionInformation(mGui->enlightenedValue, ":/enlightened", mWaniKani.srsDistribution().enlightened());
    updateSrsDistributionInformation(mGui->burnedValue, ":/burned", mWaniKani.srsDistribution().burned());

    mGui->userInformationValue->show();
    mGui->apprenticeValue->show();
    mGui->guruValue->show();
    mGui->masterValue->show();
    mGui->enlightenedValue->show();
    mGui->burnedValue->show();
    mCurrentRadicalsProgress->show();
    mCurrentKanjiProgress->show();

    mGui->topSeparator->show();
    mGui->nextLessonsValue->show();
    mGui->nextReviewsValue->show();
    mGui->nextHourReviewsValue->show();
    mGui->nextDayReviewsValue->show();
    mReviewsTimeLine->show();

    // Retrieve various information about our radicals

    int radicalsProgress = 0;
    int radicalsTotal = 0;

    mCurrentRadicalsReviews = Reviews();
    mAllRadicalsReviews = Reviews();

    foreach (const Radical &radical, mWaniKani.radicals()) {
        if (radical.level() == mWaniKani.level()) {
            if (radical.userSpecific().srsNumeric() >= 5)
                ++radicalsProgress;

            ++radicalsTotal;
        }

        if (radical.userSpecific().availableDate()) {
            QDateTime dateTime = QDateTime::fromTime_t(radical.userSpecific().availableDate());

            if (radical.level() == mWaniKani.level())
                mCurrentRadicalsReviews.insert(dateTime, mCurrentRadicalsReviews.value(dateTime)+1);

            mAllRadicalsReviews.insert(dateTime, mAllRadicalsReviews.value(dateTime)+1);
        }
    }

    // Retrieve various information about our Kanji

    int kanjiProgress = 0;
    int kanjiTotal = 0;

    mCurrentKanjiState = QMap<QChar, QString>();
    mAllKanjiState = QMap<QChar, QString>();

    mCurrentKanjiReviews = Reviews();
    mAllKanjiReviews = Reviews();

    foreach (const Kanji &kanji, mWaniKani.kanjis()) {
        if (kanji.level() == mWaniKani.level()) {
            if (kanji.userSpecific().srsNumeric() >= 5)
                ++kanjiProgress;

            ++kanjiTotal;
        }

        if (kanji.level() <= mWaniKani.level())
            mCurrentKanjiState.insert(kanji.character(), kanji.userSpecific().srs());

        mAllKanjiState.insert(kanji.character(), kanji.userSpecific().srs());

        if (kanji.userSpecific().availableDate()) {
            QDateTime dateTime = QDateTime::fromTime_t(kanji.userSpecific().availableDate());

            if (kanji.level() == mWaniKani.level())
                mCurrentKanjiReviews.insert(dateTime, mCurrentKanjiReviews.value(dateTime)+1);

            mAllKanjiReviews.insert(dateTime, mAllKanjiReviews.value(dateTime)+1);
        }
    }

    // Retrieve various information about our vocabulary

    mCurrentVocabularyReviews = Reviews();
    mAllVocabularyReviews = Reviews();

    foreach (const Vocabulary &vocabulary, mWaniKani.vocabularies()) {
        if (vocabulary.userSpecific().availableDate()) {
            QDateTime dateTime = QDateTime::fromTime_t(vocabulary.userSpecific().availableDate());

            if (vocabulary.level() == mWaniKani.level())
                mCurrentVocabularyReviews.insert(dateTime, mCurrentVocabularyReviews.value(dateTime)+1);

            mAllVocabularyReviews.insert(dateTime, mAllVocabularyReviews.value(dateTime)+1);
        }
    }

    // Determine our radicals and Kanji progressions

    static const QString ProgressToolTip = "<table>\n"
                                           "    <thead>\n"
                                           "        <tr>\n"
                                           "            <td align=center><strong>%1</strong></td>\n"
                                           "        </tr>\n"
                                           "    </thead>\n"
                                           "    <tbody>\n"
                                           "        <tr>\n"
                                           "            <td align=center>%2/%3 (%4%)</td>\n"
                                           "        </tr>\n"
                                           "    </tbody>\n"
                                           "</table>\n";

    double currentRadicalsValue = double(radicalsProgress)/radicalsTotal;
    double currentKanjiValue = double(kanjiProgress)/kanjiTotal;

    mCurrentRadicalsProgress->setValue(currentRadicalsValue);
    mCurrentRadicalsProgress->setToolTip(ProgressToolTip.arg("Radicals Progress")
                                                        .arg(radicalsProgress)
                                                        .arg(radicalsTotal)
                                                        .arg(int(100*currentRadicalsValue)));

    mCurrentKanjiProgress->setValue(currentKanjiValue);
    mCurrentKanjiProgress->setToolTip(ProgressToolTip.arg("Kanji Progression")
                                                     .arg(kanjiProgress)
                                                     .arg(kanjiTotal)
                                                     .arg(int(100*currentKanjiValue)));

    // Determine the next, next hour and next day reviews

    QDateTime now = QDateTime::currentDateTime();
    QDateTime nextDateTime = now;
    int diff = INT_MAX;
    int nbOfRadicalsReviews[6] = {0, 0, 0, 0, 0, 0};
    int nbOfKanjiReviews[6] = {0, 0, 0, 0, 0, 0};
    int nbOfVocabularyReviews[6] = {0, 0, 0, 0, 0, 0};

    determineReviews(mCurrentRadicalsReviews, mAllRadicalsReviews, now,
                     nextDateTime, diff, nbOfRadicalsReviews);
    determineReviews(mCurrentKanjiReviews, mAllKanjiReviews, now, nextDateTime,
                     diff, nbOfKanjiReviews);
    determineReviews(mCurrentVocabularyReviews, mAllVocabularyReviews, now,
                     nextDateTime, diff, nbOfVocabularyReviews);

    if (!nbOfRadicalsReviews[1] && !nbOfKanjiReviews[1] && !nbOfVocabularyReviews[1]) {
        nbOfRadicalsReviews[0] = mCurrentRadicalsReviews.value(nextDateTime);
        nbOfRadicalsReviews[1] = mAllRadicalsReviews.value(nextDateTime);

        nbOfKanjiReviews[0] = mCurrentKanjiReviews.value(nextDateTime);
        nbOfKanjiReviews[1] = mAllKanjiReviews.value(nextDateTime);

        nbOfVocabularyReviews[0] = mCurrentVocabularyReviews.value(nextDateTime);
        nbOfVocabularyReviews[1] = mAllVocabularyReviews.value(nextDateTime);
    }

    static const QString LessonsText = "<center>\n"
                                       "    <span style=\"font-size: 15px;\"><strong>%1</strong></span><br/>\n"
                                       "</center>\n";
    static const QString ReviewsText = "<center>\n"
                                       "    <span style=\"font-size: 15px;\"><strong>%1</strong></span><br/>\n"
                                       "    <span style=\"font-size: 11px;\">%2</span>\n"
                                       "</center>\n";
    static const QString ReviewsToolTip = "<table>\n"
                                          "    <tbody>\n"
                                          "        <tr>\n"
                                          "            <td>Radicals:</td>\n"
                                          "            <td style=\"width: 4px;\"></td>\n"
                                          "            <td align=center>%1</td>\n"
                                          "            <td style=\"width: 4px;\"></td>\n"
                                          "            <td align=center>(%2)</td>\n"
                                          "        </tr>\n"
                                          "        <tr>\n"
                                          "            <td>Kanji:</td>\n"
                                          "            <td style=\"width: 4px;\"></td>\n"
                                          "            <td align=center>%3</td>\n"
                                          "            <td style=\"width: 4px;\"></td>\n"
                                          "            <td align=center>(%4)</td>\n"
                                          "        </tr>\n"
                                          "        <tr>\n"
                                          "            <td>Vocabulary:</td>\n"
                                          "            <td style=\"width: 4px;\"></td>\n"
                                          "            <td align=center>%5</td>\n"
                                          "            <td style=\"width: 4px;\"></td>\n"
                                          "            <td align=center>(%6)</td>\n"
                                          "        </tr>\n"
                                          "    </tbody>\n"
                                          "</table>\n";
    static const QString ReviewsLink = "<a href=\"https://www.wanikani.com/review/session\""+QString(LinkStyle)+">%1</a>";
    static const QString Reviews = "%1 (%2) reviews";
    static const QString NoReviews = "No reviews";

    mGui->nextLessonsValue->setText(LessonsText.arg(mWaniKani.studyQueue().lessonsAvailable()?
                                                        QString("<a href=\"https://www.wanikani.com/lesson/session\""+QString(LinkStyle)+">%1 lessons</a>").arg(mWaniKani.studyQueue().lessonsAvailable()):
                                                        "0 lessons"));

    int nbOfReviews = nbOfRadicalsReviews[1]+nbOfKanjiReviews[1]+nbOfVocabularyReviews[1];
    int nbOfCurrentReviews = nbOfRadicalsReviews[0]+nbOfKanjiReviews[0]+nbOfVocabularyReviews[0];

    mGui->nextReviewsValue->setText(ReviewsText.arg(nbOfReviews?
                                                        (diff <= 0)?
                                                            QString(ReviewsLink.arg(Reviews)).arg(nbOfReviews).arg(nbOfCurrentReviews):
                                                            Reviews.arg(nbOfReviews).arg(nbOfCurrentReviews):
                                                        NoReviews)
                                               .arg((diff <= 0)?ReviewsLink.arg("now"):"in "+timeToString(diff)));
    mGui->nextReviewsValue->setToolTip(ReviewsToolTip.arg(nbOfRadicalsReviews[1]).arg(nbOfRadicalsReviews[0])
                                                     .arg(nbOfKanjiReviews[1]).arg(nbOfKanjiReviews[0])
                                                     .arg(nbOfVocabularyReviews[1]).arg(nbOfVocabularyReviews[0]));

    nbOfReviews = nbOfRadicalsReviews[3]+nbOfKanjiReviews[3]+nbOfVocabularyReviews[3];
    nbOfCurrentReviews = nbOfRadicalsReviews[2]+nbOfKanjiReviews[2]+nbOfVocabularyReviews[2];

    mGui->nextHourReviewsValue->setText(ReviewsText.arg(nbOfReviews?
                                                            Reviews.arg(nbOfReviews).arg(nbOfCurrentReviews):
                                                            NoReviews)
                                                   .arg("within the next hour"));
    mGui->nextHourReviewsValue->setToolTip(ReviewsToolTip.arg(nbOfRadicalsReviews[3]).arg(nbOfRadicalsReviews[2])
                                                         .arg(nbOfKanjiReviews[3]).arg(nbOfKanjiReviews[2])
                                                         .arg(nbOfVocabularyReviews[3]).arg(nbOfVocabularyReviews[2]));

    nbOfReviews = nbOfRadicalsReviews[5]+nbOfKanjiReviews[5]+nbOfVocabularyReviews[5];
    nbOfCurrentReviews = nbOfRadicalsReviews[4]+nbOfKanjiReviews[4]+nbOfVocabularyReviews[4];

    mGui->nextDayReviewsValue->setText(ReviewsText.arg(nbOfReviews?
                                                           Reviews.arg(nbOfReviews).arg(nbOfCurrentReviews):
                                                           NoReviews)
                                                  .arg("within the next day"));
    mGui->nextDayReviewsValue->setToolTip(ReviewsToolTip.arg(nbOfRadicalsReviews[5]).arg(nbOfRadicalsReviews[4])
                                                        .arg(nbOfKanjiReviews[5]).arg(nbOfKanjiReviews[4])
                                                        .arg(nbOfVocabularyReviews[5]).arg(nbOfVocabularyReviews[4]));

    // Update our wallpaper

    updateWallpaper();
}

//==============================================================================

void Widget::waniKaniError()
{
    // Something went wrong, so hide a few things

    updateGravatar(QPixmap(":/warning"));

    mGui->userInformationValue->hide();
    mGui->apprenticeValue->hide();
    mGui->guruValue->hide();
    mGui->masterValue->hide();
    mGui->enlightenedValue->hide();
    mGui->burnedValue->hide();
    mCurrentRadicalsProgress->hide();
    mCurrentKanjiProgress->hide();

    mGui->topSeparator->hide();
    mGui->nextLessonsValue->hide();
    mGui->nextReviewsValue->hide();
    mGui->nextHourReviewsValue->hide();
    mGui->nextDayReviewsValue->hide();
    mReviewsTimeLine->hide();
}

//==============================================================================

void Widget::trayIconActivated()
{
    // Make sure that we are in the centre of the screen

    QDesktopWidget desktopWidget;
    QRect availableGeometry = desktopWidget.availableGeometry();

    move(availableGeometry.center()-QPoint(width() >> 1, height() >> 1));

    // Show ourselves
    // Note: to show ourselves, one would normally use activateWindow() (and
    //       possibly raise()), but depending on the operating system it may or
    //       not bring our widget to the foreground, so instead we do what
    //       follows, depending on the operating system...

    show();

#if defined(Q_OS_WIN)
    // Show ourselves the Windows way

    // Retrieve our window Id

    HWND mainWinId = reinterpret_cast<HWND>(winId());

    // Bring us to the foreground

    DWORD foregroundThreadProcId = GetWindowThreadProcessId(GetForegroundWindow(), 0);
    DWORD mainThreadProcId = GetWindowThreadProcessId(mainWinId, 0);

    if (foregroundThreadProcId != mainThreadProcId) {
        // Our thread process Id is not that of the foreground window, so attach
        // the foreground thread to ourselves, set ourselves to the foreground,
        // and detach the foreground thread from ourselves

        AttachThreadInput(foregroundThreadProcId, mainThreadProcId, true);

        SetForegroundWindow(mainWinId);
        SetFocus(mainWinId);

        AttachThreadInput(foregroundThreadProcId, mainThreadProcId, false);
    } else {
        // Our thread process Id is that of the foreground window, so just set
        // ourselves to the foreground

        SetForegroundWindow(mainWinId);
    }
#elif defined(Q_OS_LINUX) || defined(Q_OS_MAC)
    // We are on Linux or macOS, so we can simply activate the window and raise
    // ourselves

    activateWindow();
    raise();
#else
    #error Unsupported platform
#endif
}

//==============================================================================

void Widget::updateLevels()
{
    // Update the levels to display

    if (!mInitializing)
        updateWallpaper(true);
}

//==============================================================================

void Widget::updatePushButtonColor()
{
    // Update the background colour of the given push button

    QPushButton *pushButton = qobject_cast<QPushButton *>(sender());
    QColorDialog  colorDialog;

    colorDialog.setCurrentColor(pushButton->palette().color(QPalette::Button));
    colorDialog.setOption(QColorDialog::ShowAlphaChannel);

    if (colorDialog.exec() == QDialog::Accepted) {
        setPushButtonColor(pushButton, colorDialog.currentColor().rgba());

        updateSrsDistributionPalettes();

        updateWallpaper(true);
    }
}

//==============================================================================

void Widget::setPushButtonColor(QPushButton *pPushButton, const QRgb &pColor)
{
    // Set the background of the given push button to the given colour

    static const QString PushButtonStyle = "QPushButton#%1 {"
                                           "    border: 1px solid gray;"
                                           "    background-color: rgba(%2, %3, %4, %5);"
                                           "}";

    mColors.insert(pPushButton, pColor);

    pPushButton->setStyleSheet(PushButtonStyle.arg(pPushButton->objectName())
                                              .arg(qRed(pColor))
                                              .arg(qGreen(pColor))
                                              .arg(qBlue(pColor))
                                              .arg(qAlpha(pColor)));

    if (pPushButton == mGui->enlightenedBackgroundPushButton)
        mCurrentRadicalsProgress->setColor(pColor);
    else if (pPushButton == mGui->apprenticeBackgroundPushButton)
        mCurrentKanjiProgress->setColor(pColor);
}

//==============================================================================

void Widget::checkWallpaper()
{
    // Retrieve the file name of the current wallpaper

#if defined(Q_OS_WIN)
    WCHAR tempFileName[MAX_PATH];

    SystemParametersInfo(SPI_GETDESKWALLPAPER, sizeof(tempFileName),
                         tempFileName, 0);

    QString wallpaperFileName = QString::fromUtf16(reinterpret_cast<const ushort *>(tempFileName));
#elif defined(Q_OS_MAC)
    QString wallpaperFileName = QUrl(macosWallpaper()).toLocalFile();
#else
    QProcess process;

    process.start("gsettings",
                  QStringList() << "get"
                                << "org.gnome.desktop.background"
                                << "picture-uri");
    process.waitForFinished();

    QString tempFileName = QString(process.readAll()).trimmed();
    QString wallpaperFileName = QUrl(tempFileName.mid(1, tempFileName.length()-2)).toLocalFile();
#endif

    // Update our wallpaper, if the current wallpaper file name is not the same
    // as the one in our settings (which might happen if we switch virtual
    // desktops, for example)

    if (wallpaperFileName.compare(mFileName))
        setWallpaper();

    // Check again in about one second

    QTimer::singleShot(1000, this, SLOT(checkWallpaper()));
}

//==============================================================================
// End of file
//==============================================================================
